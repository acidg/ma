% !TeX root = ../main.tex

\chapter{Introduction}\label{chapter:introduction}
In software development, reuse of code can reduce time and effort and can even enhance quality \cite{krueger1992software}.
Repositories published on the Internet are a popular source for code which offers the desired functionality.
However, when code is copied from open source software systems, licenses may be violated if its conditions are not met.
So called Copy-Left licenses like GPL, which demand copied-to software systems to adopt the same license, are critical, especially in closed-source systems.
Software may have to be published as open source afterwards like in the case of Microsoft's \glqq Windows USB/DVD Download Tool\grqq\footnote{\href{https://blogs.technet.microsoft.com/port25/2009/12/09/windows-7-usbdvd-download-tool-released-under-gplv2/}{https://blogs.technet.microsoft.com/port25/2009/12/09/windows-7-usbdvd-download-tool-released-under-gplv2/}}.
\todo{attribution to open source community?}

There are many tools available for finding copied code in a codebase.
Most of the tools are used for clone detection in order to find similar code which can be refactored for reuse to reduce redundancy and enhance software quality.
Some of them try to find copied code across projects or even provide interfaces for querying code.
Often, they are designed for single runs and need a pool of projects which they can use for comparison.
The possibility to use them for detection of license infringements on a continuous basis is very limited because of several issues.
% huge dataset
The data structure for comparison has to be built from a huge dataset of open source projects to find copied code which is a huge effort.
% no history analysis
Second, the history of the projects often is not considered which may prevent detection of copied code form older versions of a system.
When code was copied from an older version of an open source project, it may not be found.
% confidentiality
Uploading the code to a server offering copied code detection often is not an option for confidentiality reasons.

This work proposes an architecture for a tool, which allows to search a codebase for copied code from open source software available on the Internet.
To decide whether a given fragment of code is part of an open source system, the detection tool analyzes huge amounts of open source systems available on the Internet and maintains a data structure, which makes it possible to quickly search for similar fractions of code in the analyzed open source systems.
The approach proposed in this work is based on a client server architecture, where the server keeps track of several thousand open source projects.
The server provides an interface for clients, which allows them to query for code sequences and find similar matches in open source systems.
This can be done in a continuous manner, i.e. for every commit to track whether incongruously licensed code has been copied to the codebase.
One key aspect here is the filtering technique used, which significantly reduces the server's load and speeds up the search process.
The filter is a small part of the database which can be downloaded from the server.
It allows clients to decide whether a section of source code is part of an open source system tracked by the server.

\todo{requirements}

The amount of code which can be tracked by the server is in the range of several billion lines of code including history.
The analysis of existing open source code bases is fast and scalable and can be periodically updated.
To prove that, a prototype of the tool has been implemented and more than 500 million lines of code from approximately 2.000 open source projects where indexed in about 20 hours on a consumer laptop.
The database is about 37 GB, the filter's size about 200 MB for this amount of code.

\todo{library code which should be linked instead of copied, vulnerabilities in copied code}
\todo{tracking changes/history}

The work is organized as follows.
First, definitions used throughout the work as well as requirements are listed in \autoref{chapter:preliminaries}.
Subsequently, related work is depicted in \autoref{chapter:related_work} and based on that, an overview of the approach used for the tool is presented in \autoref{chapter:approach}.
Details of the implementation, decisions and its complications are shown in \autoref{chapter:implementation}.
In \autoref{chapter:evaluation} the prototype is used to analyze several thousand projects, categorize findings and evaluate their validity.
This leads to a discussion about the usefulness of the approach and proposals for future work in \autoref{chapter:conclusion}.