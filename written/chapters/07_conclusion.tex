% !TeX root = ../main.tex

\chapter{Conclusion}\label{chapter:conclusion}

\section{Continuous Detection of License Infringements}
\begin{itemize}
	\item Summarize findings and conclusion about feasibility
	\item Research questions?
\end{itemize}

\section{Future Work / Extensibility}\label{section:approach/extensibility}
\begin{itemize}
	\item TODO Optimize normalization: Method based? (removes getter/setters, since to small) block-based => switch methods/structs/enums ordering in file, if/while/for with/without braces
	\item TODO Chunk size: Size of database only influenced slightly, maybe even smaller chunks and more filtering?
	\item TODO Assess matches: \textbf{Load file(s) from server}, do more comparison (With a difftool token based on methods/blocks, to prevent reordering of methods not detected)
	\item TODO Extension points for future development? Web-Interface for code-add-request, Suggestions for linking libraries (gradle, ...)
	\item TODO Authorization? Spam protection? DoS? Restrict requests/min and size of request -> (Monetize? => Blackduck...)
\end{itemize}

\subsection{Distribution for High Loads}
Since this work proposes a client-server architecture, it is important to provide a reliable service to a huge amount of clients.
Therefor, distributing the index on several machines is desirable for load balancing.
This could easily be done by distributing the database onto the machines whenever the index is updated.

It may also be advisable to group reference projects by license or other parameters like origin of the code (GitHub, Bitbucket, Debian source repositories, \dots).
Pairs of servers and filters responsible for a group of reference projects could be created.
This would result in multiple small hash filters and enables clients to only choose filters of their interest, further reducing the size of the filter a client has to download and keep up to date.
The requests resulting from matches in the filter on the client side then have to be routed to the server responsible for the corresponding group of reference projects.

\subsection{Higher Accuracy History Analysis}
As explained in section \ref{section:implementation/history_analysis/sorting_tags} ... => Branch based

\subsection{Optimizations for the Filter}
\begin{itemize}
\item TODO: "By making a sparse Bloom filter using 48 bits per element but only 3 hash functions, one can compress the result down to less than 16 bits per item with high probability) and decrease the false positive probability by roughly a factor of 2. @Mitzenmacher, Michael; Upfal, Eli (2005), Probability and computing: Randomized algorithms and probabilistic analysis S.10
\item TODO Use Cuckoo-Filter \cite{fan2014cuckoo} instead of Bloom-Filter. Better performance in low false-positive probability with many items
\end{itemize}